[{"categories":["acwing"],"content":"蓝桥杯算法基础课第一章笔记（部分内容参考自qly同学） 算法基础课","date":"2024-02-26","objectID":"/posts/565a60b/:0:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r1 排序思路：分治 分为子序列 更分子序列 子序列处理合并 ","date":"2024-02-26","objectID":"/posts/565a60b/:1:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r1.1 快排 取中间值 分割区间 排序 再取中间值 再分割子区间 在排序 区间合并 void quick_sort(int q[],int l, int r){ if(l\u003e=r) return; int i=l-1,j=r+1; //初始位置 int x=q[l+r\u003e\u003e1]; //中间值位置 选择j时不变，选择i时l+r+1 （边界问题） while(i\u003cj){ //逐次处理 do i++; while(q[i]\u003cx); //注意起点位置 do j--;while(q[j]\u003ex); if(i\u003cj) swap(q[i],q[j]); //单次交换 } quick_sort(q,l,j); //递归处理子区间 quick_sort(q,j+1,r); } 注： while(i\u003cj)不能写成 i\u003c=j,这样会多做一次循环，导致跳出循环时i\u003ej。跳出循环时i应该和j相等。 注意i、j模板与初始分界点x的关系。 如果初始分界点x取左端点或者右端点，在所有数都一样的情况下，时间复杂度会退化到 O($n^2$)，原为$n*log_2(n)$ ","date":"2024-02-26","objectID":"/posts/565a60b/:1:1","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r1.2 归并思路：分治 找出分界点，分界点取数组的中间位置（与快速排序不同，分界点取中间位置的数值）。 分界后对两边做递归排序。 归并，合二为一。（从小到大则是取较小值放到tmp中，从大到小则是取较大值放到tmp中） 时间复杂度：$n*log_2(n)$。（n对2取对数） void merge_sort(int q[],int l,int r){ if(l\u003e=r) return; int mid=l+r\u003e\u003e1; //边界点确定 merge_sort(q,l,mid); //递归 merge_sort(q,mid+1,r); int k=0,i=l,j=mid+1; //两边初值 while(i\u003c=mid\u0026\u0026j\u003c=r){ if(q[i]\u003cq[j]) //取小值赋值 tmp[k++]=q[i++]; else tmp[k++]=q[j++]; } while(i\u003c=mid) //取剩余 tmp[k++]=q[i++]; while(j\u003c=r) tmp[k++]=q[j++]; for (i=l,j=0;i\u003c=r;i++,j++) q[i]=tmp[j]; //排序后赋值 从l到r } 注： while(i\u003c=mid\u0026\u0026j\u003c=r) 两边循环到底 注意i、j模板与初始分界点mid的关系。 时间复杂度稳定为$n*log_2(n)$ 与快排不同，需要空间存储，故数据量小时适合归并 ","date":"2024-02-26","objectID":"/posts/565a60b/:1:2","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r2 二分思路：分治 二分出分界点 数据含一定规律：从符合规则到不符合规则 整数二分存在边界问题（$=$ 号位置） bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u003e eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 左右边界： 看mid点位置 不满足-满足 左边界 满足-不满足 右边界 ","date":"2024-02-26","objectID":"/posts/565a60b/:2:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r3 高精度计算思路：模仿手算 加法 后一位补 减法 后一位借 乘法 后一位补 除法 后一位借 ","date":"2024-02-26","objectID":"/posts/565a60b/:3:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r3.1 加法 // C = A + B, A \u003e= 0, B \u003e= 0 vector\u003cint\u003e add(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) { if (A.size() \u003c B.size()) return add(B, A); vector\u003cint\u003e C; int t = 0; for (int i = 0; i \u003c A.size(); i ++ ) { t += A[i]; if (i \u003c B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } ","date":"2024-02-26","objectID":"/posts/565a60b/:3:1","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r3.2 减法 // C = A - B, 满足A \u003e= B, A \u003e= 0, B \u003e= 0 vector\u003cint\u003e sub(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) { vector\u003cint\u003e C; for (int i = 0, t = 0; i \u003c A.size(); i ++ ) { t = A[i] - t; if (i \u003c B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u003c 0) t = 1; else t = 0; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } ","date":"2024-02-26","objectID":"/posts/565a60b/:3:2","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r3.3 乘法 // C = A * b, A \u003e= 0, b \u003e= 0 vector\u003cint\u003e mul(vector\u003cint\u003e \u0026A, int b) { vector\u003cint\u003e C; int t = 0; for (int i = 0; i \u003c A.size() || t; i ++ ) { if (i \u003c A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } ","date":"2024-02-26","objectID":"/posts/565a60b/:3:3","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r3.4 除法 // A / b = C ... r, A \u003e= 0, b \u003e 0 vector\u003cint\u003e div(vector\u003cint\u003e \u0026A, int b, int \u0026r) { vector\u003cint\u003e C; r = 0; for (int i = A.size() - 1; i \u003e= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } ","date":"2024-02-26","objectID":"/posts/565a60b/:3:4","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r4 前缀和与差分","date":"2024-02-26","objectID":"/posts/565a60b/:4:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r4.1 前缀和（累加生成序列） 4.1.1 一维类比数列 $S(n)=\\sum_{i=0}^{n}a(i) $ 则有 $S[i] = a[1] + a[2] + … a[i]$ $a[l] + … + a[r] = S[r] - S[l - 1]$ #include\u003ciostream\u003e using namespace std; const int N=1e5+10; int a[N],sum[N];//全局变量默认初始值为0 int main(){ int m,n,x; cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ex; sum[i]=x+sum[i-1];//sum[i]表示序列中前i个数之和 } int l,r; for(int i=0;i\u003cm;i++){ cin\u003e\u003el\u003e\u003er; //注意是l-1，因为l到r之间的数之和包括第l个数 printf(\"%d\\n\",sum[r]-sum[l-1]); } } 4.1.2 二维$S(m,n)=\\sum_{j=0}^{n} \\sum_{i=0}^{m} a(i,j) $ $S[x1–x2,y1–y2]=S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]$ x-1 ：点阵 #include\u003ciostream\u003e using namespace std; const int N=1010; int S[N][N],a[N][N];//a用于存放矩阵，s是矩阵的前缀和矩阵 int main(){ //1.读入数据 int n,m,q; cin\u003e\u003en\u003e\u003em\u003e\u003eq; for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++){ cin\u003e\u003ea[i][j]; } } //2.初始化和矩阵 for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++){ S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]; } } //3.计算(x1,y1)和(x2,y2)之间的数之和 int x1,y1,x2,y2; while(q--){ cin\u003e\u003ex1\u003e\u003ey1\u003e\u003ex2\u003e\u003ey2; cout\u003c\u003cS[x2][y2]-S[x2][y1-1]-S[x1-1][y2]+S[x1-1][y1-1]\u003c\u003cendl; } } ","date":"2024-02-26","objectID":"/posts/565a60b/:4:1","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r4.2 差分思路： 前缀和的逆运算 a[i]=b[1]+b[2]+b[3]+···+b[i]，则称b为a的差分数组，a为b的前缀和，且b满足： ​ b[1]=a[1]; ​ b[2]=a[2]-a[1]; ​ b[3]=a[3]-a[2]; ​ b[n]=a[n]-a[n-1]; a[i]+c,对b数组的影响是b[i]+c，并且b[i+1]-c。(从a[i]=b[1]+b[2]+b[3]+···+b[i]中可以得到） ​ a数组的第l到r个数＋c，对b数组的影响是b[l]+c并且b[r+1]-c。 步骤： 确定插入方式 构造原始序列（0序列满足差分及前缀和） 插入获取目标序列（同时生成相应差分序列） 4.2.1 一维给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c #include\u003ciostream\u003e using namespace std; const int N=100010; int n,m,a[N],b[N]; void insert(int l,int r,int c){ b[l]+=c; b[r+1]-=c; } int main(){ cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i]; for(int i=1;i\u003c=n;i++) insert(i,i,a[i]); int l,r,c; while(m--){ cin\u003e\u003el\u003e\u003er\u003e\u003ec; insert(l,r,c); } //a是b的前缀和，求完之后b的值也就变成自身的前缀和了，也就是a for(int i=1;i\u003c=n;i++) b[i]+=b[i-1],cout\u003c\u003cb[i]\u003c\u003c' '; } 4.2.2 二维给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： B[x1, y1] += c B[x2 + 1, y1] -= c B[x1, y2 + 1] -= c B[x2 + 1, y2 + 1] += c #include \u003ciostream\u003e using namespace std; const int N=1010; int a[N][N],b[N][N]; void insert(int x1,int y1,int x2,int y2,int c){ //1.前缀和a矩阵在(x1,y1)到(x2,y2)的范围整体加c，对b的影响 b[x1][y1]+=c; b[x1][y2+1]-=c; b[x2+1][y1]-=c; b[x2+1][y2+1]+=c; } int main(){ int n,m,q; scanf(\"%d%d%d\",\u0026n,\u0026m,\u0026q); //1.读入数据 for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++){ scanf(\"%d\",\u0026a[i][j]); } } //2.初始化差分数组 for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++){ insert(i,j,i,j,a[i][j]); } } //3.循环处理 while(q--){ int x1,y1,x2,y2,c; cin\u003e\u003ex1\u003e\u003ey1\u003e\u003ex2\u003e\u003ey2\u003e\u003ec; insert(x1,y1,x2,y2,c); } //4.得到b的前缀和a for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++){ a[i][j]=b[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1]; cout\u003c\u003ca[i][j]\u003c\u003c' '; } cout\u003c\u003cendl; } return 0; } ","date":"2024-02-26","objectID":"/posts/565a60b/:4:2","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r5 双指针思路： 原始做法 双指针简化流程（思考是否具备相关过程） for (int i = 0, j = 0; i \u003c n; i ++ ) { while (j \u003c i \u0026\u0026 check(i, j)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 数组元素的目标和 给定两个升序排序的有序数组 A和 B，以及一个目标值 x。 数组下标从 0 开始。 请你求出满足 A[i]+B[j]=x的数对 (i,j)。 数据保证有唯一解。 #include\u003ciostream\u003e using namespace std; const int N=100010; int a[N],b[N]; int main(){ //1.读入数据 int n,m,x; scanf(\"%d%d%d\",\u0026n,\u0026m,\u0026x); for(int i=0;i\u003cn;i++) scanf(\"%d\",\u0026a[i]); for(int i=0;i\u003cm;i++) scanf(\"%d\",\u0026b[i]); //2.双指针相向移动 找出i j for(int i=0,j=m-1;i\u003cn;i++){ while(a[i]+b[j]\u003ex \u0026\u0026 j\u003e=0){ j--; } if(a[i]+b[j]==x) { printf(\"%d %d\\n\",i,j); break; } } } ","date":"2024-02-26","objectID":"/posts/565a60b/:5:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r6 位运算求n的第k位数字 n是一个十进制数，要求n的二进制表达里的第k位数字 n»k\u00261 以下代码会输出n=10的二进制表达 int n=10; for(int i=31;i\u003e=0;i--) cout \u003c\u003c (x \u003e\u003e i \u0026 1); 求十进制数n的二进制表达中，最后一位1，比如10的二进制表达是1010，最后一位1是10，10100的最后一位1是100。 lowbit函数实现如下： int lowbit(int x){ return x \u0026 (-x); } 关于lowbit的那些事 - 凌云_void - 博客园 (cnblogs.com) 3.例题： 统计一个十进制数的二进制表达中1的个数 #include\u003ciostream\u003e using namespace std; int lowbit(int x){ return x \u0026 (-x); } int main(){ //1.有n个数据 int n; cin\u003e\u003en; while(n--){ //2.每次对一个数据做计算处理 int number; cin\u003e\u003enumber; int num=0; //3.当数据不为0时说明数据的二进制表示里还有1 while(number){ number-=lowbit(number); num++; } cout\u003c\u003cnum\u003c\u003c' '; } } ","date":"2024-02-26","objectID":"/posts/565a60b/:6:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r7 离散化思路： 定规则（满足二分条件） 二分离散 vector\u003cint\u003e alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (alls[mid] \u003e= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 例题 ​ 假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。 ​ 现在，我们首先进行 n次操作，每次操作将某一位置 x上的数加 c。 ​ 接下来，进行 m 次询问，每个询问包含两个整数 l和 r，你需要求出在区间 [l,r]之间的所有数的和。 #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e using namespace std; typedef pair\u003cint,int\u003e PII; const int N=300010; int a[N],s[N];//存放所有下标的值和前缀和 vector\u003cPII\u003e add,query;//add存储插入的数对x,c query存储查询的数对l,r vector\u003cint\u003e alls;//存放所有出现的下标，包括插入的x和查询的左右边界l r int find(int x){ int l=0,r=alls.size()-1; while(l\u003cr){ int mid = l + r \u003e\u003e 1; if(alls[mid]\u003e=x) r=mid; else l=mid+1; } return r+1;//代表在区间1，2，3···到alls.size()映射 } int main(){ int n,m; cin\u003e\u003en\u003e\u003em; //1.读取n个要插入的数据 for(int i=1;i\u003c=n;i++){ int x,c; cin\u003e\u003ex\u003e\u003ec; add.push_back({x,c}); alls.push_back(x); } //2.读取m对要查询的左右边界 for(int i=1;i\u003c=m;i++){ int l,r; cin\u003e\u003el\u003e\u003er; query.push_back({l,r}); alls.push_back(l); alls.push_back(r);//记得把左右边界的下标也一并记录 } //3.对下标进行排序并去重 sort(alls.begin(),alls.end()); alls.erase(unique(alls.begin(),alls.end()),alls.end()); //4.离散化 //离散化就是把大而分散的一段段使用到的稀疏区间，整合映射到连续的一段较小的稠密区间里 for(auto item:add){ int x=find(item.first); a[x]+=item.second; } //5.预处理前缀和 for(int i=1;i\u003c=alls.size();i++) s[i]=s[i-1]+a[i]; //6.开始查询 for(auto item:query){ int l=find(item.first),r=find(item.second);//先找边界映射的下标 int sum = s[r] - s[l-1]; cout\u003c\u003csum\u003c\u003cendl; } } ","date":"2024-02-26","objectID":"/posts/565a60b/:7:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r8 区间合并思路：贪心 目标：合并具有交集的区间 条件： 有序规则 交集 // 将所有存在交集的区间合并 void merge(vector\u003cPII\u003e \u0026segs) { vector\u003cPII\u003e res; sort(segs.begin(), segs.end());//排序 int st = -2e9, ed = -2e9; //起始区间（前一个区间） for (auto seg : segs) if (ed \u003c seg.first) //区间没有交集则 独立并剔出 前一个区间 { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); //存在交集则 扩大前一个区间 但不剔出 if (st != -2e9) res.push_back({st, ed}); //加入最后一个区间 segs = res; } #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; typedef pair\u003cint,int\u003e PII; vector\u003cPII\u003e segs; void merge(vector\u003cPII\u003e \u0026segs){ vector\u003cPII\u003e res;//用于存储合并后的区间 //1.将区间按照左端点大小升序排序（默认按照segs.first排序） sort(segs.begin(),segs.end()); //2.开始合并 int st = -2e9,ed=-2e9;//st ed存储上一个区间的左右端点 for(auto seg :segs){ //如果当前区间的左端点大于上一个区间的右端点 说明上一个区间独立了 if(seg.first \u003e ed){ if(st!=-2e9) res.push_back({st,ed});//第一次循环不执行 //把当前区间作为要维护的下一个区间 st = seg.first, ed = seg.second; } //如果当前区间的左端点不大于上一个区间的右端点 那么合并当前和上一个区间 else ed = max(ed,seg.second); } if(st!=-2e9) res.push_back({st,ed});//记得把最后一个区间的结果加进去 segs = res; } int main(){ int n; cin\u003e\u003en; while(n--){ int l,r; cin\u003e\u003el\u003e\u003er; segs.push_back({l,r}); } merge(segs); cout\u003c\u003csegs.size()\u003c\u003cendl; } 数据结构核心：数组模拟-数据结构 原因：new（）动态分派操作非常慢 ","date":"2024-02-26","objectID":"/posts/565a60b/:8:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r1 链表与邻接表","date":"2024-02-26","objectID":"/posts/565a60b/:9:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r1.1 单链表 单链表：邻接表（存储 图、树）（n个单链表） 存在内存浪费，但算法题中不考虑 #include\u003ciostream\u003e using namespace std; const int N = 100010; //head 表示头结点是插入的第几个数据 //e[N]表示节点的值 //ne[N]表示节点下一个指向第几个插入的数据 //idx表示插入到第几个数据 int head,e[N],ne[N],idx; //初始化 void init(){ head = -1; idx = 0; } //向链表头插入一个数x void add_to_head(int x){ idx++; e[idx] = x; ne[idx] = head; head = idx; } //表示在第 k个插入的数后面插入一个数 x void add(int k,int x){ idx++; e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; } //表示删除第k个插入的数后面的数 记得考虑k=0的情况，即删除头结点 void remove(int k){ if(!k) head = ne[head]; else ne[k] = ne[ne[k]]; } int main(){ init(); int m; cin\u003e\u003em; while(m--){ char op; cin\u003e\u003eop; if(op=='H'){ int x; cin\u003e\u003ex; add_to_head(x); } if(op=='D'){ int k; cin\u003e\u003ek; remove(k); } if(op=='I'){ int k,x; cin\u003e\u003ek\u003e\u003ex; add(k,x); } } for(int i=head;i!=-1;i=ne[i]){ cout\u003c\u003ce[i]\u003c\u003c' '; } } 第二种处理方式，注意idx++位置引起的区别 #include\u003ciostream\u003e using namespace std; const int N=100010; int head,e[N],ne[N],idx; void init(){ head=-1; idx=0; } void add_to_head(int x){ e[idx]=x; ne[idx]=head; head=idx; idx++; } void add(int k, int x){ e[idx]=x; ne[idx]=ne[k]; ne[k]=idx; idx++; } void remove(int k){ ne[k]=ne[ne[k]]; //不能为ne[k++] } int main(){ init(); int m; cin\u003e\u003em; while(m--){ char op; cin\u003e\u003eop; if(op=='H'){ int x; cin\u003e\u003ex; add_to_head(x); } if(op=='D'){ int k; cin\u003e\u003ek; if(!k) head = ne[head]; remove(k-1); } if(op=='I'){ int k,x; cin\u003e\u003ek\u003e\u003ex; add(k-1,x); } } for(int i=head;i!=-1;i=ne[i]){ cout\u003c\u003ce[i]\u003c\u003c' '; } } ","date":"2024-02-26","objectID":"/posts/565a60b/:9:1","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r1.2 双链表 双链表：优化某些问题 #include\u003ciostream\u003e using namespace std; const int N=100010; int e[N],l[N],r[N],idx; //初始化 void init(){ r[o]=1; l[1]=0; idx=2;//前两个节点已经使用 } //k点右插为主所写， k点左插=add(l[k],x) void add(int k,int x){ e[idx]=x; r[idx]=r[k];//1 l[idx]=k;//2 l[r[k]]=idx;//3 r[k]=idx; //4 //l[r[idx]]=idx; 可和3交换 } //删除第k个点 void remove(int k){ r[l[k]]=r[k]; l[r[k]]=l[k]; } ","date":"2024-02-26","objectID":"/posts/565a60b/:9:2","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r2 栈与队列","date":"2024-02-26","objectID":"/posts/565a60b/:10:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r2.1 栈 // tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空，如果 tt \u003e 0，则表示不为空 if (tt \u003e 0) { } ","date":"2024-02-26","objectID":"/posts/565a60b/:10:1","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r2.2 队列普通队列 // hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空，如果 hh \u003c= tt，则表示不为空 if (hh \u003c= tt) { } 循环队列 // hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空，如果hh != tt，则表示不为空 if (hh != tt) { } ","date":"2024-02-26","objectID":"/posts/565a60b/:10:2","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r2.3 单调栈与单调队列（抽象但题型较少）朴素做法-\u003e优化无效值-\u003e观察单调性-\u003e优化 ","date":"2024-02-26","objectID":"/posts/565a60b/:10:3","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r2.4 单调栈严格单调 强调目标：最近 且 较小 相当于“最近”指标权重更大 故逆序对or相等时 较远的元素无优势 故严格单调 常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i \u003c= n; i ++ ) { while (tt \u0026\u0026 check(stk[tt], i)) tt -- ; stk[ ++ tt] = i;//必须压入元素 此处++tt表示栈顶+1位置 } ","date":"2024-02-26","objectID":"/posts/565a60b/:10:4","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r2.5 单调队列（滑动窗口） 常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i \u003c n; i ++ ) { while (hh \u003c= tt \u0026\u0026 check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh \u003c= tt \u0026\u0026 check(q[tt], i)) tt -- ; q[ ++ tt] = i; } ","date":"2024-02-26","objectID":"/posts/565a60b/:10:5","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r3 KMP核心：快速移动 · 所需匹配模板字符串 ，从而降低时间复杂度 步骤： 1、原始做法逐个字母开始 匹配 2、思考如何简化，发现如果存在最大的前缀和后缀相等，那么可以直接进行移动，此举大大加快了速率 移动的前提： 知道最大的前缀和后缀相等时是多少，即知道next数组 求取next数组： 考虑对模板字符串进行自匹配，需要求取 ne[1]、ne[2]乃至ne[N] 故采用循环的方式，逐步从2~m 以此扩大所匹配的字符串，匹配用模板前缀匹配模板后缀，同时进行赋值计算 注意到，当目标字符串为k时 匹配的模板字符串最大为k-1 故赋值时可以赋值到ne[k-1]，所以模板匹配时无需担心ne[i], i\u003ck不存在 参考解释： AcWing 831. KMP字符串 - AcWing // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 求模式串的Next数组： for (int i = 2, j = 0; i \u003c= m; i ++ ) { while (j \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i \u003c= n; i ++ ) { while (j \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } ","date":"2024-02-26","objectID":"/posts/565a60b/:11:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r4 Tier高效地存储和查找字符串 ","date":"2024-02-26","objectID":"/posts/565a60b/:12:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r5 并查集集合为基本元素 1、将两个集合合并 2、询问两个元素是否在一个集合中 近乎o(1)的时间复杂度内完成相应操作 基本原理： 集合用树表示 根节点p[x]=x 问题1：如何判断树根： p[x]==x 问题2：如何求x的集合编号： while(p[x]!=x) x=p[x]; 问题3：如何合并两个集合：px，py两个集合编号 合并：p[x]=y即可 路径压缩优化（按秩合并优化未讲–用的少） scanf(“s%”) 扫描字符串会过滤回车，但是c%不会，因此对单个字符也可采用字符串进行处理（过滤空格和回车）（血的教训ovo） int find(int x) //返回x的祖宗节点+路径压缩 { if(p[x]!=x) p[x]=find[p[x]]; return p[x]; } #include\u003ciostream\u003e using namespace std; const int N=100010; int p[N],sz[N],n,m; int find(int x){//找到编号为x的数的集合编号 + 路径压缩 if(p[x]!=x) p[x]=find(p[x])//如果该节点不是根节点则让其父节点等于根节点（递归实现路径压缩） return p[x]; } int main(){ scanf(\"%d%d\",\u0026n,\u0026m); for (int i=0;i\u003cn;i++){ p[i]=i; sz[i]=1; } while(m--){ char op[5]; int a,b; scanf(\"%s\",op); if(op[0]=='C'){ scanf(\"%d%d\",\u0026a,\u0026b); if find(b)==find(a) continue; sz[find(b)]+=sz[find(a)]; p[find(a)]=find(b);//注意要在根节点的size相加之后再合并，两句话不能颠倒 } else if(op[1] == '1'){ scanf(\"%d%d\",\u0026a,\u0026b); if(find(a)==find(b)) puts(\"Yes\"); else puts(\"No\"); } else{ scanf(\"%d\",\u0026a); printf(\"%d\\n\",sz[find(a)]); } } return 0; } ","date":"2024-02-26","objectID":"/posts/565a60b/:13:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["acwing"],"content":"\r6 堆堆：完全二叉树 小根堆：每个点小于等于左右子节点（根节点为最小值）（左右叶子节点无大小关系） 如何手写一个堆 1、插入一个数 2、求集合当中的最小值 3、删除最小值 stl无法实现的内容： 4、删除任意元素 5、修改任意元素 存储：一维数组 根节点：1 左子节点：2x 右子节点2x+1 两个操作： 节点上下移动：down(x) up(x) ","date":"2024-02-26","objectID":"/posts/565a60b/:14:0","tags":["acwing"],"title":"蓝桥杯第一章笔记","uri":"/posts/565a60b/"},{"categories":["tools"],"content":"记录一次评论设置流程 ","date":"2024-02-15","objectID":"/posts/bb019d3/:0:0","tags":["tools"],"title":"评论设置流程","uri":"/posts/bb019d3/"},{"categories":["tools"],"content":"\r1 参考 Waline 官方指南快速上手 | Waline ","date":"2024-02-15","objectID":"/posts/bb019d3/:1:0","tags":["tools"],"title":"评论设置流程","uri":"/posts/bb019d3/"},{"categories":["tools"],"content":"\r2 HugoserverURL=客户端URL即可 ","date":"2024-02-15","objectID":"/posts/bb019d3/:2:0","tags":["tools"],"title":"评论设置流程","uri":"/posts/bb019d3/"},{"categories":["tools"],"content":"记录一次图床配置流程 ","date":"2024-02-15","objectID":"/posts/eb9b3b7/:0:0","tags":["tools"],"title":"图床设置流程","uri":"/posts/eb9b3b7/"},{"categories":["tools"],"content":"\r1 前情提要 阿里云OSS（对象存储）（收费：9元/年） PicGo ","date":"2024-02-15","objectID":"/posts/eb9b3b7/:1:0","tags":["tools"],"title":"图床设置流程","uri":"/posts/eb9b3b7/"},{"categories":["tools"],"content":"\r2 阿里云OSS服务设置","date":"2024-02-15","objectID":"/posts/eb9b3b7/:2:0","tags":["tools"],"title":"图床设置流程","uri":"/posts/eb9b3b7/"},{"categories":["tools"],"content":"\r2.1 基础OSS服务搭建 登录阿里云 对象存储OSS 选择并购买OSS资源包（9元/年） 创建bucket 注： 读写权限：公共读 ","date":"2024-02-15","objectID":"/posts/eb9b3b7/:2:1","tags":["tools"],"title":"图床设置流程","uri":"/posts/eb9b3b7/"},{"categories":["tools"],"content":"\r2.2 用户设置 创建专门用于访问OSS的用户 注： 记录ACCESSID和ACCESSSECRET（仅创建时可以查看，后续无法再次看到） 添加OSS权限 ","date":"2024-02-15","objectID":"/posts/eb9b3b7/:2:2","tags":["tools"],"title":"图床设置流程","uri":"/posts/eb9b3b7/"},{"categories":["tools"],"content":"\r3 配置PicGo1、下载并安装PicGo Releases · Molunerfinn/PicGo (github.com) 2、打开PicGo，打开图床设置，点击阿里云OSS，如下设置即可 ","date":"2024-02-15","objectID":"/posts/eb9b3b7/:3:0","tags":["tools"],"title":"图床设置流程","uri":"/posts/eb9b3b7/"},{"categories":["tools"],"content":"\r4 MarkDown结合1、偏好设置-\u003e图像 确定上传服务 2、Markdown完成后点击上传所有图片 ","date":"2024-02-15","objectID":"/posts/eb9b3b7/:4:0","tags":["tools"],"title":"图床设置流程","uri":"/posts/eb9b3b7/"},{"categories":["draft"],"content":"姑娘： 你听我说。 我原以为相遇一定是书诗成画，歌文谱曲。要闹市马蹄下救人，荒山破庙中避雨。是英雄救美，道一声得罪。是火堆取暖，听一夜风雨。要游园忽闻佳人笑，转头又见桃花开。是万朵桃花都失色，是十里春风总不如。是你一颦一笑一回眸，要我灯火阑珊千百度。是可作诗歌可谱曲，要这样诗情画意。 后来我以为相遇一定是这辈子必定会推开的一扇门。门后面是万里明媚，百草欣荣。是小哑巴拿着波板糖，四目交接，眼波流转。见到就知道，相逢如重逢。推开这扇门，用尽一身的力气和一生的运气。知道门的那边有你，就什么都不在再保留，拼尽全力。是这样毫无顾忌。 再后来我以为相遇一定是一场无限期有目的的旅行。要披星戴月，披荆斩棘。要历经岁月的沧桑和尘世的烦扰，要忍受沉默的世界和空荡的长街。要坐错车下错站，要哭过长夜要难以入眠。是翻过篱笆高墙，站在你面前。是迎着风雪，站在你面前。是假装有缘，站在你面前。是无数次巧合，才骗得一个驻足。要这样真实。 我原先以为是我在茫茫寻找，是听着风来自地铁和人海。是过尽千帆，整理千次发型。虽然等待的时间无比慢无比长，但知道你会来，便等得。就是这个道理。 可姑娘，爱情哪有什么道理。 什么诗书画意，什么命运之门，什么等待、旅行全是放屁。 直到我遇见了你。 我只觉得冬天再不要穿的臃肿，去见你必然要刷牙洗头。 睡前醒后会想到你，出门回家也会想到你。 感冒上火想告诉你，看到下雪花开也想告诉你。 我想留下所有的蛋糕，就是因为多了一个你。 就是因为多了一个你，我觉得便去何处都可行，便是何种相遇都可行，不需要以前想的那样画意，那样浪漫，那样真实。 都不需要了。 我曾以为是我摒除杂念，足以明悟真谛。 是有了风花，雪月自当出现。是应了景，自当出现该有的情怀。我曾以为我见到了红线，就摸到了姻缘。 还是想的太过简单。 才知道，倒了一杯热水，还没凉，就渴了。 事情哪有那么多巧合那么多姻缘天定。是要自己去拼凑路灯和街景来完成浪漫。 突然想到，世间安得两全法，不负如来不负卿。 遇到了，你便和信仰一般重要，世间最珍贵的东西也就和你五五开。 舟济人过河，你济我度世。 不过还好，还好在二十出头见到你。 有了牵你手的梦想。一生说起来漫长，却不足以陪着你去看大漠孤烟长河落日，去听山风满楼雨雪连天。想要和你一起体验种种未知，思念与爱恋。要你靠在我肩上。你看风景，我看你。 姑娘，这铺满群星静寂的夜，透过窗缝低吟的风都不是我想你的理由。这老旧台灯晕开柔和的光，爬满字迹透着局促纸张，都不是我想你的方式。 都不是。 我想起以前四处找你，在对面的房间，小巷深处的窗户。在等车时的空隙，看看路的拐角 。在十字路口，在我的身后。明知道你不在那里。 也有人想替我找到你，但假如只是要找个驱赶寂寞的人，找谁应该都可以。但是在那些群星都坠落的夜里，我骗不了自己。 没想到你就这样没伴随光影，没身披祥云的出现了。 那天是不是风晴雨停，春闹枝头我不记得了，是不是宝马香车，灯火珊阑我也不记得了。大概这辈子也都不能忘了你了。 不，该是一定忘不了。 我该说些坚硬的话，像冬雷夏雪乃相离，或该说些圆转的话，像执子之手白头不离。总归是要说些什么。我怕等青春潦草成过往，再没有心境没有时机坦陈心迹。怕我踏遍青石桥等你，你撑油纸伞而来，又坐乌篷船远去。 那可太遗憾。 姑娘，我说了这么多，也不过就是五分悸动，三分激动，两分酸气，一颗真心。若你能看到这里，我也十分感激。 茨维塔耶娃说，我想和你一起生活，在某个小镇，共享无尽的黄昏，和绵绵不绝的钟声。 我也如此想着。 修正自：你写过最动人的情书是怎样的？ -叔离 ","date":"2024-02-14","objectID":"/posts/f96b3a4/:0:0","tags":["draft"],"title":"一封情书","uri":"/posts/f96b3a4/"},{"categories":["note"],"content":"\r雷达图（无边框）https://echarts.apache.org/examples/zh/editor.html?c=radar\u0026renderer=svg\u0026code=PYBwLglsB2AEC8sDeAoWtJgDYFMBcya6GOAHmAQOSVEC-ANEbgOY7QAmBqxs7AhmD4EA2pQBCOCACsI0ZpXqxKAFQh9oM6AqUAJHACNJ2ygGUAFutIRjAOUkBbNs2YBXSgF06jdACc-_Hy4idAB6ENgAZwsQfCUAYwgfONwFYNhZdgg4gWBA2GE09CRYaD5HKn0-OIBrZh9gFw5tez5SAgBGWAZC5BKy2MpZZtaOru8eXtLypQawYbbYTu6Jyf6qWQAzLBc2OJx50eXid3GjiJwfCBwIkTTuCamBsRd2VjBYADcIyJiOWXlxjwwABPGJUPwBVIrfiCW4rIo9HgfPjbWLCAAMADoACwANgA7LiAJy4gDMpIATPQsfiKQAOClE9oU9rUzEUgCs-I5uPa6I5HLZ2PauOx2PR7VJJ0RxEeVAk0n-UPh6AiwPs-mAWCo0Bg-0B8L4PhwfBMINwQRVPDiWtyVAAkD5mJUABTtbGKdpE9GKTmC2BYjkAShoVrGMvQWFkODNwIthDD6BtWDtSkdzr4Lp9AcU2fRIYj4ZVRxW9xVyNRIixpOxFIp2JJHI9WM59fFYrpbPR-LpTKJTM7WOxHPR2NJPdH0rDcqUqnUmmVKrVGq1Or1i8NxtN5tiZatydTlCdro5pN9pKJnt5ucxwdDVpL8Kj0BjO8tiYPeUo6ddedzuYLMNHx4YDiD3FYKx2Kt2U5Olx3ROlm3ZdFcVHOl2nxLsiQ5Xt-yJKksXdDl-1JSUpQNFYZ0oPRDGsCiJmXTVtSUXUXw3FYjRNWN43A-FP3BDMXXrKlFm9T0vRvO9C1Anhn1fONd0LJNbS_H9Mz_HMA0Ah96PQGSEytSC0UI9DGSZGs2T5SkKXxdoMK7GtEPdXECMxOzvVxXt8XIwsqPMSw6MLRjVxY9ddOITjtwU98w34pRj0zesz1gMTYDJSTtOLcLI2jbjFMTWA4u_BKs3_TT83vLKZX03ikRRKD8kInsKU8lDB0xFDxVxXkmy7OsR1FSlLLswkJVJXEpytKi7AgRw5FcdiGPVJi1zY7LYEivKYv3FSBJPZKKQvK9WQDW9MvhfScpfLaDNi3a0xKjS83OlZ9NoHpPBAohPFoABuIA 雷达图（+边框）https://echarts.apache.org/examples/zh/editor.html?c=radar\u0026renderer=svg\u0026code=PYBwLglsB2AEC8sDeAoWtJgDYFMBcya6GOAHmAQOSVEC-ANEbgOY7QAmBqxs7AhmD4EA2pQBCOCACsI0ZpXqxKAFQh9oM6AqUAJHACNJ2ygGUAFutIRjAOUkBbNs2YBXSgF06jdACc-_Hy4idAB6ENgAZwsQfCUAYwgfONwFYNhZdgg4gWBA2GE09CRYaD5HKn0-OIBrZh9gFw5tez5SAgBGWAZC5BKy2MpZZtaOru8eXtLypQawYbbYTu6Jyf6qWQAzLBc2OJx50eXid3GjiJwfCBwIkTTuCamBsRd2VjBYADcIyJiOWXlxjwwABPGJUPwBVIrfiCW4rIo9HgfPjbWLCAAMADoACwANgA7LiAJy4gDMpIATPQsfiKQAOClE9oU9rUzEUgCs-I5uPa6I5HLZ2PauOx2PR7VJJ0RxEeVAk0n-UPh6AiwPs-mAWCo0Bg-0B8L4PhwfBMINwQRVPDiWtyVAAkD5mJUABTtbGKdpE9GKTmC2BY0kAShoVrGMqOK3uKuRqJEgexFIp2JJHI9WM5yfFYrpbPR-LpTKJTNzWOxHPR2NJBcr0rDcqUqnUmmVKrVGq1Or1rcNxtN5ti0atNqwdqUTtdHNJvtJRM9vMUgZDMvQtAjBp4Q5WsZ28fZnLp1fRdPT7PRuMrdPa-LzRI5heLRKpWPdHOLpMlUo3DzWugMRm_Hh201bUlF1aB9RXWAjRNM1gQtQgw3QEcx0oCc-BdZMqUWb1PS9RdMWDUMrTXFVIwmLcJh3NEXyvRkmVJU8-UpCl8Xaa880Yk93VxZ9MXY71cULfEvyghtTAsaArB7FZgM7MDu0A4gYP7eDByg5DbTyNDnQw5Np1gXDYDJAiiKg0j4XIzcoOovdrwZITz1LTFz3FXFeTTPMkwrUVKTZdjrwvSVcTrK1xLsCBHDkVwZImOTQMocDILDFS4IQyiVhQ7T0JdKcZznRYFwDQjlzDCyVnK440gszxaAAbiAA 三维柱状图https://echarts.apache.org/examples/zh/editor.html?c=bar3d-punch-card\u0026gl=1\u0026code=PTAEAcCcFMBdYJbUgWgQcwHYHsYCgA3AQ0lAAtsBXSAZ1AF5QBtAcgCFoEArBTdFgDSgWAFQRFMPTIOEAJaACNOMlgGUyEgB4IVAOU4BbaH3SUZeUJdABdANx4QEGPCSoMOfMVIATIgE86RlYFIgBjAGt0SCpMbxVeFSpYQQsrFl4AMwAbSmNQ6BY7BzAoOERkNCxcaEISUF9YIgZmJgAGAXbWgDoAFgA2AHY-gE4-gGYxgCZrASYARg6OroHJgA5J4bnJuZmmScXuyYBWVd2xg965vp7d9oXusZ7p2YX7ruPnvYE31oHV4bO3yWPSOrRus3a-0Ox1OLwEUPerT6u32CNawyOANm5wRc36twE526c1WczGuwWRK6c1aUxRhKWtJ6sKY5ypczmmwJPSWcz-5LhPO6SPBXyFXVak2OgPFHL51iK2HAiGwmGaAG9UrBsNgsohwAAuUDqgC-AlSBAQNEoRCyAFkiIbjalLAYiJojQsXaBeAAlCToaBGzVWKyhXW4I1Mb2hlgAYjGZJGRxSodjcZBAyOCh6qbTlnjAx6RG83jmefz8aICm8w2gwwrafj0FaGTGGVWjfTGR7GQUGS7aTjGWgLeGrUHBeHvmgfXL5vzU4y_W8PTGk-Ece8AzGkoGG6roMlfRYMZs3pNqTNqU0AEFtDQxgARYPe2B-cBB4ShIiwaDoXA_EbBoiCNChqBoK8F1APx7ytZ9X1Dd9PyNFgfz_ADICA6DLBAo1fACKDUgALzgx8X2dJCPy_FhiByAoiMsKIEG8BDKKsBRsE0AB1FjYDII1JladpvU4zQn2gZUBNAVYRNDS1oAAdwAYVVWBoiyRC00cKBsC4aBQhVTBUNwfjsCiR0yAQUJT1Da9QyyDAyFgLTQzdXhXLTXg_0wGgEHfT13hwtMaA0bxsEUo0MltGganzey0yIAwFCQTAXPY_NvOMPyAtAB4z0vOzGNAWLICQGgo29EM02QmiQkgZ9Bzw-pfyILo3XAAAKDJKEwQyEFVUBOv86ADAASgytNnGoNVqsXUA6NyKMRoMeYZh9P9VtadaVr2BUz0sE17HisbgssUKS14dBUKyJKlEgZIztAW6lE0ybQwyNTVAQYivyuJ7LE4yBvGQXjvH4z0Cqe0bwA0PyKveqwXugN65sXT60u-37BLk-bQHDLJI03ccJwO0AEsyzbVHfLIvzR_MCaJ-MSdsxdCrTdnDtSaw8COoA 分数折线图（stack）https://echarts.apache.org/examples/zh/editor.html?c=line-stack\u0026code=PYBwLglsB2AEC8sDeAoWtJgDYFMBcya6GOAHmAQOQDKYAhgMYDWOAJrADITQ6VEC-AGiJhgwLJBAFUxDACcIAc0U45VOqQgBnPuiFFcK6K2lF0rOvQIBtSgCNGTRXOABXY5UGxK3T97dgfj7QAGZYrjjQDLxelKL0WJQAugLC6M4QJoSyuCEU3gDMAKSeZrAKigAW-ZQALCVpxHbAYKIAtlTFpbIMMPTcHHR2OFgEYHIRqSJiWM2kprIhOJaucvjZsrBadABuOACCWgCSbXQq0vxll3qNpPuaWgvEYACeIOuUDJY4isByL90mm5jHR_gBxOhSWAhO","date":"2024-01-13","objectID":"/posts/d4e50c0/:0:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r1 堆叠柱状图的可视化Examples - Apache ECharts ","date":"2024-01-13","objectID":"/posts/d4e50c0/:1:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r2 堆叠条形图Examples - Apache ECharts ","date":"2024-01-13","objectID":"/posts/d4e50c0/:2:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r3 嵌套环形图Examples - Apache ECharts ","date":"2024-01-13","objectID":"/posts/d4e50c0/:3:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r4 指数回归Examples - Apache ECharts ","date":"2024-01-13","objectID":"/posts/d4e50c0/:4:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r5 线性回归Examples - Apache ECharts ","date":"2024-01-13","objectID":"/posts/d4e50c0/:5:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r6 多项式回归Examples - Apache ECharts ","date":"2024-01-13","objectID":"/posts/d4e50c0/:6:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r7 对数回归Examples - Apache ECharts ","date":"2024-01-13","objectID":"/posts/d4e50c0/:7:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r8 柱状图+饼状图Examples - Apache ECharts ","date":"2024-01-13","objectID":"/posts/d4e50c0/:8:0","tags":["mathmodel"],"title":"图表绘制","uri":"/posts/d4e50c0/"},{"categories":["note"],"content":"\r数据搜集","date":"2024-01-12","objectID":"/posts/e826d29/:0:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r0.1 常用的数据网站汇总 - 知乎 (zhihu.com)","date":"2024-01-12","objectID":"/posts/e826d29/:0:1","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r0.2 参加美赛需要用到哪些数据网站？ - 知乎 (zhihu.com)","date":"2024-01-12","objectID":"/posts/e826d29/:0:2","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r1 1 搜索引擎Dataset Search (google.com)（谷歌数据集） Google 学术搜索 ","date":"2024-01-12","objectID":"/posts/e826d29/:1:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r2 2 Our world in dataCharts - Our World in Data ","date":"2024-01-12","objectID":"/posts/e826d29/:2:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r3 3 Github数据集汇总awesomedata/awesome-public-datasets: A topic-centric list of HQ open datasets. (github.com) ","date":"2024-01-12","objectID":"/posts/e826d29/:3:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r4 4 常用数据集https://www.gapminder.org/data/ 下载一些常用的数据集，可以是csv格式 ","date":"2024-01-12","objectID":"/posts/e826d29/:4:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r5 5 规划云http://guihuayun.com/规划云，可以在线在网络上进行爬虫，傻瓜式操作，地图可视化 ","date":"2024-01-12","objectID":"/posts/e826d29/:5:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r6 6 数据竞赛平台 KaggleKaggle: Your Home for Data Science ","date":"2024-01-12","objectID":"/posts/e826d29/:6:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r7 美能源信息国际 - 美国能源信息署 （EIA） ","date":"2024-01-12","objectID":"/posts/e826d29/:7:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r8 美水稻年鉴","date":"2024-01-12","objectID":"/posts/e826d29/:8:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r9 国家统计局数据 - 国家统计局 (stats.gov.cn) ","date":"2024-01-12","objectID":"/posts/e826d29/:9:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r10 世界银行[数据目录 (worldbank.org)](https://datacatalog.worldbank.org/search?fq=(geographical_extent%2Fcoverage%2Fany(geo:geo%2Fname eq ‘China’))\u0026q=edu\u0026sort=\u0026start=0) ","date":"2024-01-12","objectID":"/posts/e826d29/:10:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r11 Google数据集Dataset Search (google.com) ","date":"2024-01-12","objectID":"/posts/e826d29/:11:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r12 UCI数据库Datasets - UCI Machine Learning Repository ","date":"2024-01-12","objectID":"/posts/e826d29/:12:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r13 大数据导航大数据导航-大数据工具导航-199IT大数据导航-199IT大数据工具导航-Hao.199it.com ","date":"2024-01-12","objectID":"/posts/e826d29/:13:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r14 和鲸社区https://www.kesci.com/home 和鲸社区，也可以找到一些常用的数据 ","date":"2024-01-12","objectID":"/posts/e826d29/:14:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r15 美国政府开放数据包含气候、教育、能源金融等各领域数据 https://link.zhihu.com/?target=http%3A//Data.gov ","date":"2024-01-12","objectID":"/posts/e826d29/:15:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r16 海面温度climate4you OceanTemperaturesAndSeaLevel ","date":"2024-01-12","objectID":"/posts/e826d29/:16:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r17 地理数据Earthdata Search | Earthdata Search (nasa.gov) Photo 2 PDFhttps://www.hipdf.cn/crop-pdf PDF裁剪器，可以将图片导出为pdf格式，之后裁剪，避免论文模糊 PDF 2 EPS 矢量图https://www.alltoall.net/pdf_eps/ pdf到eps的格式转换工具，同样是避免直接插图论文变的模糊，转换为矢量格式 地图可视化Map Editor - create interactive maps for your websites (amcharts.com) ELSEhttps://www.sciencedirect.com/ 搜专业论文 https://link.springer.com/ 搜专业论文 https://www.fotor.com.cn/app.html#/design 设计一些好看的图片 ","date":"2024-01-12","objectID":"/posts/e826d29/:17:0","tags":["mathmodel"],"title":"数据搜集","uri":"/posts/e826d29/"},{"categories":["note"],"content":"\r科技写作课堂笔记","date":"2023-12-23","objectID":"/posts/f96b412/:0:0","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r1 p1：科技写作很重要课堂讲述内容： 1、email 2、paper 3、pc 4、ps（personal statement 提示： 1、明白：科研的重要性（与保研相关） 2、推荐一本书：MIT how to win in college 3、科技写作需关注：论文的投递时间 4、明确：kpi的变化与 writing密切相关 5、写论文需要注意：论文的审稿周期，由此确定投递时间 ","date":"2023-12-23","objectID":"/posts/f96b412/:1:0","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r2 p2、email","date":"2023-12-23","objectID":"/posts/f96b412/:2:0","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r2.1 email 的第一原则 :礼貌1、与礼貌相关的两本书：亚当斯密:道德情操论 ＆ 马英九 （爱新觉罗）金赙冲 （对老师影响最大） 1、核心: 双方的认可 + 客观社会的认可 2、核心注意事项: 一事一意 3、单件事需要保证: 完整、周全 4、参照物： 中国几大名贴，如《快雪时晴帖》 1、科技型写作要点: 结构简单、逻辑简单、明确事情本身/原因/现象/后果 2、如何写好: 做笔记、定期阅读高质量杂志 3、如何做笔记： 对应的语言 对应的案例 4、好的图片： nature science的图片怎么来的（对图的要求极高） 训练： 1、经济学人: 科技栏目 明确： 1、target journel（目标期刊） ","date":"2023-12-23","objectID":"/posts/f96b412/:2:1","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3 p3、Paper概览（详解部分：Abstract及之前）","date":"2023-12-23","objectID":"/posts/f96b412/:3:0","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3.1 1、title1、要求： ​ 至少包含一下两点： ​ 1）反映“到底是一个什么样的工作” ​ 句式： for…… ​ 2）包含核心技术 ​ 句式：……for 2、核心： ​ 吸引读者阅读 3、建议： ​ 不要太花里胡哨、异想天开（罗马城非一日之功） ​ ","date":"2023-12-23","objectID":"/posts/f96b412/:3:1","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3.2 2、author1、第一作者最重要 2、个人名字（期刊中）： ​ 确定后勿改 3、作者人数： ​ （一般不要超过3-4人）（最好3人）（不要只有1个） 4、邮箱： ​ 正式且永久（可选gmail） ​ 非永久邮箱注意关联（论文作者以邮箱相关） 5、作者排名： ​ 现阶段听导师的 ​ 注：勿自己提议加谁，觉得有出力可以提一下 ","date":"2023-12-23","objectID":"/posts/f96b412/:3:2","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3.3 3、Abstract1、关键：不可造假 2、句式：7-8句 第一句：为什么要做（关键\u0026难） ​ 句式：尽管…. 还….. 需要…. 第二句：主流方法最大的困难\u0026最大的瓶颈 ​ （痛点 难点 第三句：为了解决，我们提出…… ​ （方法引入 ​ （可以比标题扩充一点 ​ （希望用长句 第四-五句/六句 叙述方法 ​ 方法分几步 ​ 两句概括 一句强调亮点 最后一句： 效果很好 ​ 前提：效果好，广泛实验，广泛对比 ​ 数据方面：通用 个人数据集 ​ 方法方面： notion： ​ 1、英文写作最重要的环节: 用好副词 ​ 2、非英文母语 者，少许介词错误可以接受 tips： ​ 1、面临抉择时，不妨极端化（放大看自己到底怎么选） 一个原则： ​ 1、abstract 和 正文相互 独立 ​ 2、缩写第一次出现时放括号里 ​ 3、abstract 和 正文里 共两遍 关注： ​ 让你爱不释手的东西 ​ in particular部分(建议中等长度句 ","date":"2023-12-23","objectID":"/posts/f96b412/:3:3","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3.4 4、key words1、部分杂志只允许固定词库内选择(便于 审稿人与稿件配对 2、允许的情况下关键词应符合下述条件： 核心任务\u0026关键技术(标题部分\u0026相符 3、3-5个即可 ","date":"2023-12-23","objectID":"/posts/f96b412/:3:4","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3.5 5、Introduction","date":"2023-12-23","objectID":"/posts/f96b412/:3:5","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3.6 6、Related work / background","date":"2023-12-23","objectID":"/posts/f96b412/:3:6","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3.7 7、Experiments and disscusion / analysis","date":"2023-12-23","objectID":"/posts/f96b412/:3:7","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r3.8 可加项：\r3.8.1 8、 appendix\r3.8.2 9 、acknowledgement致谢里 需要双方的认可才可加 3.8.3 10、 note","date":"2023-12-23","objectID":"/posts/f96b412/:3:8","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r4 p4、Paper详解（详解部分：Introduction及之后）科技写作 两个关键词（原则）： consistent（宏观上、风格上，比如：介绍他人时用过去时or现在时） diverse(语言上) 4.0.4 1.1、 Introduction（摘要）最重要为什么摘要最重要： ​ 写文章是为了”发表“ ，所以，为让人看下去 ，Introduction很重要 4.0.4.1 第一段: 要解决的问题很重要达到目的： ​ 使人同意：要解决的问题很重要 4.0.4.2 第二段: 技术很重要达到目的: ​ 所提出的方法解决相应问题很重要 注意： 1、一定要“说得准” 2、高度凝炼 高度概括 要求: 1. 结构简单 2. 信息量丰富 4.0.4.3 第三段：我的方法​ 第二段、第三段过渡： ​ 第二段:概述现有方法优缺点并指出问题 为第三段我的方法做铺垫 4.0.4.4 第四段：概述创新方法和贡献1、一个原则: ​ 科技写作的核心观点（最高原则）:逻辑 2、现有方法分为几类 ​ 通常第一页某边上分一个较好的图 3、几个选择 现有方法暴露的问题 暴露的问题\u0026对比 4.0.4.5 第五段：最简单\r4.0.5 A. 杂谈一（论文审稿流程）1、可供发表的地方: ​ conference journel（会议\u0026期刊） ​ 1、会议档次:CCF A/B/C.（中国计算机协会 推荐会议ABC） ​ 2、讲述内容: 期刊 （IEEE Springor） 2、审查员组成： ​ Edition chief 总编辑(最重要） + 其他成员 组成指导委员会 (责任编辑） + 另一些人（咨询） ​ 即：admin(秘书? 看格式） + Edition chief（主编） + AE(责任编辑） ＆ （邀请3-5个审稿人） 3、审核决定： 拒稿/修改/发表 4、学习场所：coursera 5、Mit algorithm(算法） 4.0.6 1.2、Introduction（详解）\r4.0.6.1 第二段(related work的高度总结）1、需描述：现有的方法有几类 2、对难以归类的 ：note(值得一提的是) 3、分类边界取决于核心意图：一切为核心服务 4、注意点明现有方法的主要优缺点 5、第二段应是出现最多引用文献的地方 6、结束时点明方法的问题、 7、围绕自己的方法而铺垫 4.0.6.2 第三段（我的methods）1、并列点明分阶段(语言应丰富 （特别是关于：内容，理念） 2、特别点明主要点 4.0.6.3 第四段（p4 必不可少）（显式地点明 独创性\u0026创新点）1、创新点通常 3点 2、建议分布： ​ 其中一点与实验有关 (可以增加说服力） ​ 不能少于三点 不能多与四点 ​ 从frame work(整体上） 找 or 强调 某个“核心技术” 解决了某个 “核心问题” 4.0.6.4 第五段1、各章节做了什么事 注：第一页右上角加图： 吸引读者阅读兴趣 4.0.7 B. 杂谈二（写作工具（学长介绍））1、latex-网页在线 2、latex 科技排版 3、beamer 4.0.8 2.1、Realated work\r4.0.8.1 论文审稿结果1、四种情况： ​ 1.accept ​ 2.minor review ​ 3.major review ​ 4.reject 2、需要进行：revise\u0026resummit 3、一般过程： 由3-2-1 4、注意： ​ 提交修改稿的同时 ​ 1.revised sub ​ 2.response later 4.0.8.2 闲谈1、真科研与伪科研（劳动密集型 2、论文审稿两种情况：单盲 与 双盲 3、对reaponse latter 应该：对不合理的意见，应模糊的拒绝 4、由此引入：人生不是选择题 5、科研笔记（Note） 两个功能: 1.科研启发 思路方法创新(思想上的启迪 2.语言 组织 创新(表达上的帮助 4.0.9 2.2、Realted work（详解）题语： 1、与笔记密切相关 2、做笔记很重要 3、推荐杂志:ACM survey（convincing） 4.0.9.1 第一段:综述现行方法注： 1、category（分类别，逻辑清晰 2、好的文章的图 应做到 自完备：(不看字 可看懂图 （necessary important 3、caption(标题 应做到自完备 一些原则： 每段不要太长 结构要简单(段内总分总(写不下可 段内分节点 讲的什么 细节 问题 要为引出我的方法做铺垫 (不相关的方法少谈 第三部分(可选方法中用到的重要模块 or 总结(没用好 定义好 策略 (注：保持总分总结构） 明确一点： related work的质量=分析+reference(多少合适? 5篇经典的+5篇最新的 目标期刊 reference来源： –来源于:顶刊 –来源于:顶尖机构 (大学(顶尖机构(学科 code evlable –好的教材 好的期刊 好的source code 注： 1、数字不要做主语 2、不要用某某 提出了 什么 3、应该用方法做主语 (规范不清楚即查找目标期刊相关样例 4.0.10 3、Our Method/Work原则: 1.有一张 图 (代表完整工作 (标题足够描写出所学内容 (设计得 美轮美奂 (跨栏 的图 2.定义讲清楚 (数学符号讲清楚 (关键性的概念的定义 核心概念 3、方法包括几部分? 3—5部分 4、应包括：几何+语义 5、可以有最后一个subsection： 杂项 注意（implement detail）： 1、必须保证清晰的逻辑 2、低级结构可以用a、b、c、d划分 3、1个选择 算法的运行顺序 step1-4 4、数学符号注意事项： 标量 小写 向量 加粗小写 矩阵 大写 (其余可看相关文档 ​ 同时：所用方法涉及的数学分支要知道 注意： 1、不要出现流程图 ( 太 low 2、算法用对应形式表示 3、建议最多有一个 跨栏的 大图 4、充分利用工具 ​ 标注 要规范 ​ 工具箱中工具要用好 5、所做问题应有数学描述 4.0.11 4、exprimental result1、主要目的：验证（verify (extensive insightful 强有力的验证） 2、实验部分：1/3-1/2 3、数据保障(公共数据 采集数据 4、比较应充分 (可包括： 1、2-3个当前最火 效果最好的方法 2、今年的方法1-2个 3、最相似的方法1-2个 4、自己的方法 ​ 5、方法内比较 ​ 定性 ​ 定量 6、仿真数据+真实数据 7、Figure table text 8、可加?补充材料 9、对比应该公正 10、以上 general 要求 4.0.12 organize:一般4部分 ​ 1.preparation ​ 2.数据+明确比较对象 ​ 3.项目实验 ​ 自组织(包含所有实验) ​ 注：讨论不是对图表的再描述，而应该是深刻的讨论 4.0.13 5 、conclusion\u0026future work1、多读多看多写 2、是abstract基础上的应用，思考伟大之处\u0026改进空间 4.0.14 C. 杂谈三（科研工具）1、note express / one note 2、connected papers 3、mendelay 4、paperswithcode 5、letpub 4.0.15 D. 杂谈四（将来的选择）提示： 1、所有能偷懒的办法都要检查一遍 2、投的target journel要引用相应的journel 文章 未来的选择： location: China wuhan North american us/canada europe uk/瑞士/德国 north europe asia singopora/hong kong/沙特 Austrlia career： 1.governnent 2.university 3.institute 4.industry 5.others 啃老 6.internet celebraty 注： 1、locatuin 与 career对应 2、government 去 中国\u0026新加坡 3、university去 北美uk新加坡 4、不去德国日本(慢 严谨 5、institute 去 china 6、北美 欧洲 7、公司 去 美国瑞士新加坡 8、working parse permitted 9、others 其他选不上的时候选australian ","date":"2023-12-23","objectID":"/posts/f96b412/:4:0","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["note"],"content":"\r5 p5、personal statement1、为什么写：为了被接受 2、几个原则: 海投 (拼命的投 全美前50 全球前50 如果条件允许，请中介 找到关心，支持的prof(推荐人 (两三个 三四个的 口碑比较好的 乐意帮助小朋友的 注：不同的ps不应完全一样，可以是70%基本信息 30%针对性信息。 5.0.16 可涉及的点：1.拉关系 ​ 1、拉近距离 ​ 2、找链接点 ​ 3、应具备：政治正确、人文关怀 ​ 4、有高度 2.介绍自己 ​ 雄心壮志 3.讲业绩 ​ 亮点 4.重要项目 5.大学生活 6.奖项 7.成绩 8.呼应前文 To whom it may concern 1、老师 交代清楚 2、亮点要点清楚 ​ 如： ​ 高尚、开朗、性格好、热情、互动性强、适应职位 DS(engineer finance） ECE:EE+CE ICRA ","date":"2023-12-23","objectID":"/posts/f96b412/:5:0","tags":["learn"],"title":"科技写作课堂笔记","uri":"/posts/f96b412/"},{"categories":["Leaf"],"content":"Decoding Lab: Understanding a Secret Message分析解答 未完待续 ","date":"2023-03-30","objectID":"/posts/process/:0:0","tags":["draft","note"],"title":"Decoding Lab: Understanding a Secret Message解答（未完待续）","uri":"/posts/process/"},{"categories":["Leaf"],"content":"\r1 分析","date":"2023-03-30","objectID":"/posts/process/:1:0","tags":["draft","note"],"title":"Decoding Lab: Understanding a Secret Message解答（未完待续）","uri":"/posts/process/"},{"categories":["Leaf"],"content":"\r1.1 已给提示 先解key1 key2 后解key3 key4（12解出前34无法解） 如key1 key2解正确 则显示：~From:~ （仅用于检验key1 key2是否正确） process_key12会改变dummy的值（因为statrt、stride值因dummy值而变） 解key3 key4时调用process_key34而非process_key12，在process_key34中实现该过程 ","date":"2023-03-30","objectID":"/posts/process/:1:1","tags":["draft","note"],"title":"Decoding Lab: Understanding a Secret Message解答（未完待续）","uri":"/posts/process/"},{"categories":["Leaf"],"content":"\r1.2 key1\u0026key2\r1.2.1 函数主体 int dummy = 1; int start, stride; int key1, key2, key3, key4; char* msg1, * msg2; key3 = key4 = 0; if (argc \u003c 3) { usage_and_exit(argv[0]); } key1 = strtol(argv[1], NULL, 0); key2 = strtol(argv[2], NULL, 0); if (argc \u003e 3) key3 = strtol(argv[3], NULL, 0); if (argc \u003e 4) key4 = strtol(argv[4], NULL, 0); process_keys12(\u0026key1, \u0026key2); start = (int)(*(((char*)\u0026dummy))); stride = (int)(*(((char*)\u0026dummy) + 1)); if (key3 != 0 \u0026\u0026 key4 != 0) { process_keys34(\u0026key3, \u0026key4); } msg1 = extract_message1(start, stride); 1.2.2 分析：由msg1 = extract_message1(start, stride);有：smg1与start与stride相关（与提示相符） start = (int)(*(((char*)\u0026dummy))); stride = (int)(*(((char*)\u0026dummy) + 1)); 结合此处，可知dummy数据发生改变 由前文分析可知process_keys12(\u0026key1, \u0026key2);改变了dummy地址 void process_keys12(int* key1, int* key2) { *((int*)(key1 + *key1)) = *key2; } 则*((int*)(key1 + *key1))=dummy=*key2 key1=\u0026dummy-\u0026key1 又有： int dummy = 1; int start, stride; int key1, key2, key3, key4; 则应有 key1=3 由前文知：key2=dummy msg1 = extract_message1(start, stride); char* extract_message1(int start, int stride) { int i, j, k; int done = 0; for (i = 0, j = start + 1; !done; j++) { for (k = 1; k \u003c stride; k++, j++, i++) { if (*(((char*)data) + j) == '\\0') { done = 1; break; } message[i] = *(((char*)data) + j); } } message[i] = '\\0'; return message; } 分析此循环有：从data数组第start+2个字符开始读取，每读取stride-1个字符即跳过一个字符 对 int data[] = { 0x63636363, 0x63636363, 0x72464663, 0x6F6D6F72, 0x466D203A, 0x65693A72, 0x43646E20, 0x6F54540A, 0x5920453A, 0x54756F0A, 0x6F6F470A, 0x21643A6F, 0x594E2020, 0x206F776F, 0x79727574, 0x4563200A, 0x6F786F68, 0x6E696373, 0x6C206765, 0x796C656B, 0x2C336573, 0x7420346E, 0x20216F74, 0x726F5966, 0x7565636F, 0x20206120, 0x6C616763, 0x74206C6F, 0x20206F74, 0x74786565, 0x65617276, 0x32727463, 0x6E617920, 0x680A6474, 0x6F697661, 0x20646E69, 0x21687467, 0x63002065, 0x6C6C7861, 0x78742078, 0x6578206F, 0x72747878, 0x78636178, 0x00783174 }; 数据进行输出分析有： cccccccccFFrromo: mFr:ie ndC TTo:E Y ouT Gooo:d! NYowo tury cEhoxoscineg lkelyse3,n4 tto! fYoroceu a cgalol tto eextvraectr2 yantd havioind gth!e caxllx txo xexxtrxacxt1x 要使得输出为：From: 需 从第11个开始 读2个隔1个 则start=9 \u0026 stride=3 又有 start = (int)(*(((char*)\u0026dummy))); stride = (int)(*(((char*)\u0026dummy) + 1)); 则dummy由int转为char类型后 第一个字节：09 第二个字节：03 当后面字节填充为0时有：*dummy=2^8^3+9=777=key2 ","date":"2023-03-30","objectID":"/posts/process/:1:2","tags":["draft","note"],"title":"Decoding Lab: Understanding a Secret Message解答（未完待续）","uri":"/posts/process/"},{"categories":["test"],"content":" 博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 ","date":"2023-02-14","objectID":"/posts/66fbaa3/:0:0","tags":["draft"],"title":"First_post","uri":"/posts/66fbaa3/"}]